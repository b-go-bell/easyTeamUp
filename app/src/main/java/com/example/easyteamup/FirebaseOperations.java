package com.example.easyteamup;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.android.gms.tasks.Task;
import com.google.firebase.auth.FirebaseAuth;
import com.google.firebase.auth.FirebaseUser;
import com.google.firebase.firestore.FieldValue;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.QueryDocumentSnapshot;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


public class FirebaseOperations {
    FirebaseAuth auth;
    FirebaseFirestore db;
    FirebaseUser authenticatedUser;

    public FirebaseOperations() {
        auth = FirebaseAuth.getInstance();
        db = FirebaseFirestore.getInstance();
    }

    /**
     * Logs in a user using firebase authentication. By default, this user
     * will remain logged in until the user is explicitly signed out.
     * @param email
     * @param password
     * @return BooleanCallback contains a bool indicating whether the login
     *      was successful or not.
     */
    public void loginUser(String email, String password, BooleanCallback bc) {
        auth.signInWithEmailAndPassword(email, password).addOnCompleteListener(task -> {
            if (task.isSuccessful()) {
                authenticatedUser = auth.getCurrentUser();
                bc.isTrue(true);
            }
            else {
                bc.isTrue(false);
            }
        });
    }

    /**
     *
     * @param user an already initialized User object with any desired profile attributes
     *             already set
     * @param password
     * @return BooleanCallback contains a bool indicating whether the login
     *      *      was successful or not.
     */
    public void registerUser(User user, String password, BooleanCallback bc) {
        auth.createUserWithEmailAndPassword(user.getEmail(), password).addOnCompleteListener(task -> {
            if (task.isSuccessful()){
                authenticatedUser = auth.getCurrentUser();
                user.setUid(authenticatedUser.getUid()); //userId has been generated, save to object


                //create Map from User
                ObjectMapper UserToMap = new ObjectMapper();
                Map <String, Object> mappedUser =   UserToMap.convertValue(user, Map.class);
                mappedUser.remove("uid");


                db.collection("users").document(authenticatedUser.getUid()).set(mappedUser);
                db.collection("users").document(authenticatedUser.getUid()).collection("pastEvents");
                bc.isTrue(true);
            }
            else bc.isTrue(false);
        });
    }

    /**
     * Will create a new event in Firestore, based on the event object passed in. Will also set the currently
     * logged in user as meeting host.
     * @param event An already initialized event object, with all desired details set.
     *              <span class = "strong">Note: Leave EventId and host as null.</span> It will be automatically
     *              generated by Firebase.
     * @return eventIdString is a callback with a String representing the automatically generated
     *              eventID for the object
     */
    public void createEvent(Event event, ObjectCallback eventIdString) {
        event.setHost(authenticatedUser.getUid());
        db.collection("events").add(event).addOnCompleteListener(task1 -> {
            if (task1.isSuccessful()) {
                String eventId = task1.getResult().getId();
                db.collection("users")
                        .document(event.getHost())
                        .update("hostedEvents", FieldValue.arrayUnion(eventId))
                        .addOnSuccessListener(documentReference -> {
                          eventIdString.result(eventId);
                        })
                        .addOnFailureListener(e -> {
                            //REMOVE HOSTED EVENT [TBD]
                            eventIdString.result(null);
                        });

            }
            else {
                eventIdString.result(null);
            }
        });
    }

    /**
     * @param uid A userid corresponding to the User that will be returned
     * @return ObjectCallback contains a User corresponding to uid, or
     * null if none exists.
     */
    public void getUserByUid(String uid, ObjectCallback userObject){
        db.collection("users").document(uid).get().addOnCompleteListener(task -> {
            if (task.isSuccessful()){
                User res = task.getResult().toObject(User.class);
                res.setUid(uid);
                userObject.result(res);
            }
            else {
                userObject.result(null);
            }
        });
    }

    /**
     *
     * @param user a user object with all desired attributes already set
     * @param uid the uid that will correspond to the user
     * @return BooleanCallback will be true if operation is succesful
     */
    public void setUser(User user, String uid, BooleanCallback bc) {
        db.collection("users").document(uid).set(user).addOnCompleteListener(task -> {
            if (task.isSuccessful()){
                bc.isTrue(true);
            }
            else {
                bc.isTrue(true);
            }
        });
    }

    /**
     * Get a list of a users' invitations and as well as their RSVP status.
     * Options are {attending, pending, rejected}
     * @param uid Represents the user who's invitations we are checking
     * @return mapObject is a Map <String, String> where the key is the eventId
     * and and the value is the invitation status.
     */
    public void getInvitedEvents(String uid, ObjectCallback mapObject) {
        db.collection("users").document(uid).get().addOnCompleteListener(task -> {
            if (task.isSuccessful()){
                Map<String, Object> userInfo = task.getResult().getData();
                mapObject.result(userInfo.get("invitedEvents"));
            }
            else{
                mapObject.result(null);
            }
        });
    }

    /**
     * Get a list of eventIds corresponding to events that a User has RSVPed for
     * @param uid Represents the user who's invitations we are checking
     * @return listObject is a List<String> containing eventsIds for all events that
     * the user has RSVPed for and confirmed that they will attend.
     */
    public void getRSVPedEvents(String uid, ObjectCallback listObject) {
        db.collection("users").document(uid).get().addOnCompleteListener(task -> {
            if (task.isSuccessful()){
                Map<String, Object> userInfo = task.getResult().getData();
                listObject.result(userInfo.get("rsvpedEvents"));
            }
            else{
                listObject.result(null);
            }
        });
    }

    /**
     * Gets a list of eventIds corresponding to events that the user has previously
     * attended.
     * @param uid
     * @return listObject is a List<String> containing eventIds for all events that the users
     * has RSVPed for and confirmed that they will attend.
     */
    public void getPastEvents(String uid, ObjectCallback listObject) {
        db.collection("users").document(uid).collection("pastEvents").get().addOnCompleteListener(task-> {
            if (task.isSuccessful()){
                List<String> invitedEvents = new ArrayList<>();
                for (QueryDocumentSnapshot document: task.getResult()){
                    invitedEvents.add(document.getId());
                }
                listObject.result(invitedEvents);
            }
            else {
                listObject.result(null);
            }
        });
    }

    /**
     * @param eventId A eventId corresponding to the Event that will be returned
     * @return ObjectCallback contains a Event corresponding to eventId, or
     * null if none exists.
     */
    public void getEventByEventid(String eventId, ObjectCallback eventObject) {
        db.collection("events").document(eventId).get().addOnCompleteListener(task -> {
            if (task.isSuccessful()) {
                Event event = task.getResult().toObject(Event.class);
                event.setEventId(eventId);
                eventObject.result(event);
            }
            else {
                eventObject.result(null);
            }
        });
    }

    /**
     * Invite a user to an event (action initiated by event host). If the user
     * has already RSVPed for an event, the invitation status will be set to
     * "attending". Otherwise, the invitation will be set to "pending".
     * @param uid Corresponds to the user being invited
     * @param eventId Corresponds to the event the user is being invited too.
     *            Note: This event should be hosted by the currently
     *            logged-in user, as only the host can make invitations.
     * @return BooleanCallback returns true if the user has been successfully
     *            invited, false otherwise. NOTE: this function makes two separate
     *            database calls. If one succeeds but the other doesn't, this function
     *            currently doesn't handle it, which leads to contradicting data. If
     *            this function ends up frequently returning false, lmk so I can
     *            do debugging and get a sense of whats going on, and also clean
     *            up the data.
     */
    public void inviteUserToEvent(String uid, String eventId, BooleanCallback bc){

        //first, check to see if the user has RSVPed to an event already
        db.collection("events")
                .document(eventId)
                .collection("RSVPedUsers")
                .document(uid)
                .get()
                .addOnSuccessListener(documentSnapshot -> {

                    //set invitation status, based on whether a user has RSVPed or not
                    String status = documentSnapshot.exists() ? "attending" : "pending";

                    //add invitation to user
                    Task<Void> updateUser = db.collection("users")
                            .document(uid)
                            .update("invitedEvents." + eventId, status);

                    //add invitation to event
                    Task<Void> updateEvent = db.collection("events")
                            .document(eventId)
                            .collection("invitedUsers")
                            .document(uid)
                            .set(new HashMap<String, Object>(){{ put("status", status); }});

                    while(!updateEvent.isComplete() || !updateUser.isComplete());
                    bc.isTrue(updateUser.isSuccessful() && updateEvent.isSuccessful());
                })
                .addOnFailureListener(listener -> {
                    bc.isTrue(false);
                });

    }

    /**
     * Gets a list of uids of all users that have RSVPed for an event.
     * NOTE: Do not use this functions to add or remove RSVPs, instead use
     * the dedicated functions for those purposes. This function should be
     * treated just like a regular getter - use it to GET information about
     * the RSVPed users, but DON'T use it to SET information about them.
     * @param eventId corresponds to the event who's RSVP list will be checked
     * @return listObject is a List<String> of uids of all rsvped guests
     */
    public void getRSVPedUsers(String eventId, ObjectCallback listObject){
        db.collection("events").document(eventId).collection("RSVPedUsers").get().addOnCompleteListener(task -> {
           if (task.isSuccessful()){
               List<String> RSVPedUsers = new ArrayList<>();
               for (QueryDocumentSnapshot document: task.getResult()){
                   RSVPedUsers.add(document.getId());
               }
               listObject.result(RSVPedUsers);
           }
           else {
               listObject.result(null);
           }
        });
    }

    /**
     * Gets a list of all users that have been invited to an event, as well
     * as their invitation status.
     * NOTE: Do not use these functions to add,remove, or modify invitations, instead use
     * the dedicated functions for those purposes. This function should be
     * treated just like a regular getter - use it to GET information about
     * the invited users, but DON'T use it to SET information about them.
     * @param eventId corresponds to the event who's RSVP list will be checked
     * @param mapObject listObject is a Map<String,String> where the key is the
     *                  uid, and the value is the invitation status, which could
     *                  be one of {attending, pending, rejected}
     */
    public void getInvitedUsers(String eventId, ObjectCallback mapObject){
        db.collection("events").document(eventId).collection("invitedUsers").get().addOnCompleteListener(task -> {
            if (task.isSuccessful()){
                Map<String,String> invitedUsers = new HashMap<>();
                for (QueryDocumentSnapshot document: task.getResult()){
                    String key = document.getId();
                    String value = (String) document.getData().get("status");
                    invitedUsers.put(key,value);
                }
                mapObject.result(invitedUsers);
            }
            else {
                mapObject.result(null);
            }
        });
    }

}
